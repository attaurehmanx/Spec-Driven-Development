# Data Model: RAG Pipeline - Agent-Based Retrieval

## Overview
This document defines the data models for the RAG pipeline system that uses OpenAI Agents SDK with Qdrant vector database to answer questions about book content.

## Core Entities

### User Query
- **Entity Name**: UserQuery
- **Description**: Represents a natural language question or request from the user about book content
- **Fields**:
  - query_id: string (unique identifier)
  - content: string (the actual question text)
  - timestamp: datetime (when the query was submitted)
  - user_id: string (optional, for session tracking)
  - session_id: string (for follow-up question tracking)

### Query Embedding
- **Entity Name**: QueryEmbedding
- **Description**: The vector representation of the user's query used for similarity search in the vector database
- **Fields**:
  - embedding_id: string (unique identifier)
  - query_id: string (reference to the original query)
  - vector: float[] (the embedding values)
  - model_used: string (which model generated the embedding)
  - created_at: datetime (timestamp)

### Retrieved Chunk
- **Entity Name**: RetrievedChunk
- **Description**: The relevant content segments retrieved from the Qdrant database that provide context for the response
- **Fields**:
  - chunk_id: string (unique identifier)
  - content: string (the actual text content)
  - score: float (relevance score from similarity search)
  - source_document: string (reference to the source document/chapter)
  - page_number: integer (optional, page reference)
  - metadata: object (additional metadata about the chunk)
  - query_id: string (reference to the query that retrieved this chunk)

### AI Agent Response
- **Entity Name**: AgentResponse
- **Description**: The final answer generated by the agent based on the retrieved context and user query
- **Fields**:
  - response_id: string (unique identifier)
  - query_id: string (reference to the original query)
  - content: string (the generated response text)
  - retrieved_chunks: string[] (IDs of chunks used in response)
  - confidence_score: float (confidence level of the response)
  - timestamp: datetime (when response was generated)
  - trace_id: string (for logging and tracing)

## Relationships

### Query to Embedding
- One UserQuery → One QueryEmbedding (1:1)
- QueryEmbedding.query_id references UserQuery.query_id

### Query to Retrieved Chunks
- One UserQuery → Many RetrievedChunks (1:N)
- RetrievedChunk.query_id references UserQuery.query_id

### Query to Agent Response
- One UserQuery → One AgentResponse (1:1)
- AgentResponse.query_id references UserQuery.query_id

### Agent Response to Retrieved Chunks
- One AgentResponse → Many RetrievedChunks (1:N)
- AgentResponse.retrieved_chunks contains RetrievedChunk.chunk_id values

## Validation Rules

### User Query Validation
- Content must not be empty (min length: 1 character)
- Content must be less than 1000 characters
- Session_id must be provided for follow-up questions

### Query Embedding Validation
- Vector must have consistent dimensions (e.g., 768 for Gemini embeddings)
- Model_used must be a valid configured model
- Vector values must be normalized

### Retrieved Chunk Validation
- Score must be between 0.0 and 1.0
- Content must not be empty
- At least one source reference must be provided

### Agent Response Validation
- Content must not be empty
- Must reference at least one retrieved chunk
- Confidence score must be between 0.0 and 1.0

## State Transitions

### Query Processing States
- NEW → EMBEDDING_GENERATED → RETRIEVAL_COMPLETE → RESPONSE_GENERATED → COMPLETE
- If no relevant chunks found: NEW → EMBEDDING_GENERATED → RETRIEVAL_COMPLETE → NO_CONTENT_FOUND → COMPLETE

### Session States
- ACTIVE → INACTIVE (after timeout or explicit end)
- Follow-up questions continue in the same session if ACTIVE

## Indexing Strategy

### Query Optimization
- Index on query_id for fast retrieval
- Index on session_id for session-based queries
- Index on timestamp for time-based queries

### Vector Search
- Qdrant handles vector similarity search natively
- Metadata fields should be indexed for filtering