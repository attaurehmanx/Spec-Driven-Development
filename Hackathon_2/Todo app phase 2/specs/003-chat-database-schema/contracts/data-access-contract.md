# Data Access Contracts: Chat Conversation Persistence

**Feature**: 003-chat-database-schema
**Date**: 2026-01-29
**Type**: Database Layer Contracts

## Overview

This document defines the data access contracts for the chat conversation persistence layer. Since this feature focuses on database schema (not API endpoints), these contracts specify how application code should interact with the Conversation and Message models.

## Contract Principles

1. **User Isolation**: All queries MUST filter by authenticated user_id
2. **Immutability**: Messages cannot be updated after creation
3. **Cascade Behavior**: Deleting a conversation deletes all its messages
4. **Chronological Order**: Messages always retrieved in created_at order
5. **Async Compatible**: All database operations support async/await

---

## Conversation Data Access Contracts

### Contract 1: Create Conversation

**Purpose**: Create a new conversation for a user

**Input**:
- `user_id`: str (required, from authenticated JWT)
- `title`: Optional[str] (max 255 chars)

**Output**:
- `Conversation` object with generated `id`, `created_at`, `updated_at`

**Constraints**:
- `user_id` must match authenticated user
- `title` is optional, can be auto-generated later
- Timestamps auto-generated by system

**Example**:
```python
conversation = Conversation(
    user_id=authenticated_user_id,
    title="Discussion about Python"
)
session.add(conversation)
session.commit()
session.refresh(conversation)
# Returns: Conversation(id=1, user_id="user_123", title="Discussion about Python", ...)
```

---

### Contract 2: List User's Conversations

**Purpose**: Retrieve all conversations for a specific user, ordered by most recent activity

**Input**:
- `user_id`: str (required, from authenticated JWT)
- `limit`: Optional[int] (for pagination)
- `offset`: Optional[int] (for pagination)

**Output**:
- List[Conversation] ordered by `updated_at DESC`

**Constraints**:
- MUST filter by `user_id` (user isolation)
- MUST order by `updated_at DESC` (most recent first)
- Should support pagination for users with 100+ conversations

**Example**:
```python
from sqlmodel import select

conversations = session.exec(
    select(Conversation)
    .where(Conversation.user_id == authenticated_user_id)
    .order_by(Conversation.updated_at.desc())
    .limit(20)
    .offset(0)
).all()
# Returns: [Conversation(...), Conversation(...), ...]
```

---

### Contract 3: Get Single Conversation

**Purpose**: Retrieve a specific conversation with ownership validation

**Input**:
- `conversation_id`: int (required)
- `user_id`: str (required, from authenticated JWT)

**Output**:
- `Conversation` object if found and owned by user
- `None` if not found or not owned by user

**Constraints**:
- MUST validate `user_id` matches conversation owner
- Return None (not error) if conversation doesn't exist or user doesn't own it

**Example**:
```python
conversation = session.exec(
    select(Conversation)
    .where(Conversation.id == conversation_id)
    .where(Conversation.user_id == authenticated_user_id)
).first()
# Returns: Conversation(...) or None
```

---

### Contract 4: Update Conversation

**Purpose**: Update conversation metadata (title, updated_at)

**Input**:
- `conversation_id`: int (required)
- `user_id`: str (required, from authenticated JWT)
- `title`: Optional[str] (new title)

**Output**:
- Updated `Conversation` object

**Constraints**:
- MUST validate user owns conversation
- MUST update `updated_at` timestamp
- Cannot change `user_id` (immutable)

**Example**:
```python
from datetime import datetime

conversation = session.get(Conversation, conversation_id)
if conversation and conversation.user_id == authenticated_user_id:
    conversation.title = "Updated Title"
    conversation.updated_at = datetime.utcnow()
    session.add(conversation)
    session.commit()
    session.refresh(conversation)
# Returns: Updated Conversation(...)
```

---

### Contract 5: Delete Conversation

**Purpose**: Delete a conversation and all its messages (cascade)

**Input**:
- `conversation_id`: int (required)
- `user_id`: str (required, from authenticated JWT)

**Output**:
- Boolean indicating success

**Constraints**:
- MUST validate user owns conversation
- MUST cascade delete all messages
- Cannot be undone

**Example**:
```python
conversation = session.exec(
    select(Conversation)
    .where(Conversation.id == conversation_id)
    .where(Conversation.user_id == authenticated_user_id)
).first()

if conversation:
    session.delete(conversation)
    session.commit()
    # All messages automatically deleted via CASCADE
    return True
return False
```

---

## Message Data Access Contracts

### Contract 6: Create Message

**Purpose**: Add a new message to a conversation

**Input**:
- `conversation_id`: int (required)
- `role`: MessageRole (required: USER, ASSISTANT, or SYSTEM)
- `content`: str (required, 1-10,000 chars)
- `user_id`: str (required, for ownership validation)

**Output**:
- `Message` object with generated `id`, `created_at`

**Constraints**:
- MUST validate user owns the conversation
- MUST update parent conversation's `updated_at` timestamp
- `role` must be valid enum value
- `content` must be 1-10,000 characters
- Messages are immutable after creation

**Example**:
```python
from datetime import datetime

# Validate conversation ownership
conversation = session.get(Conversation, conversation_id)
if not conversation or conversation.user_id != authenticated_user_id:
    raise PermissionError("User does not own this conversation")

# Create message
message = Message(
    conversation_id=conversation_id,
    role=MessageRole.USER,
    content="What are Python best practices?"
)
session.add(message)

# Update conversation timestamp
conversation.updated_at = datetime.utcnow()
session.add(conversation)

session.commit()
session.refresh(message)
# Returns: Message(id=1, conversation_id=1, role="user", content="...", ...)
```

---

### Contract 7: List Conversation Messages

**Purpose**: Retrieve all messages for a conversation in chronological order

**Input**:
- `conversation_id`: int (required)
- `user_id`: str (required, for ownership validation)

**Output**:
- List[Message] ordered by `created_at ASC`

**Constraints**:
- MUST validate user owns the conversation
- MUST order by `created_at ASC` (chronological)
- Should support 1000+ messages efficiently

**Example**:
```python
from sqlmodel import select

# Validate conversation ownership
conversation = session.get(Conversation, conversation_id)
if not conversation or conversation.user_id != authenticated_user_id:
    return []

# Get messages
messages = session.exec(
    select(Message)
    .where(Message.conversation_id == conversation_id)
    .order_by(Message.created_at.asc())
).all()
# Returns: [Message(...), Message(...), ...]
```

---

### Contract 8: Get Single Message

**Purpose**: Retrieve a specific message with ownership validation

**Input**:
- `message_id`: int (required)
- `user_id`: str (required, for ownership validation)

**Output**:
- `Message` object if found and user owns parent conversation
- `None` if not found or user doesn't own conversation

**Constraints**:
- MUST validate user owns the parent conversation
- Requires join with Conversation table for ownership check

**Example**:
```python
from sqlmodel import select

message = session.exec(
    select(Message)
    .join(Conversation)
    .where(Message.id == message_id)
    .where(Conversation.user_id == authenticated_user_id)
).first()
# Returns: Message(...) or None
```

---

## Security Contracts

### User Isolation Enforcement

**Rule**: Every data access operation MUST validate user ownership

**Implementation Pattern**:
```python
def validate_conversation_ownership(session, conversation_id: int, user_id: str) -> bool:
    """Validate that user owns the conversation"""
    conversation = session.get(Conversation, conversation_id)
    return conversation is not None and conversation.user_id == user_id

def validate_message_ownership(session, message_id: int, user_id: str) -> bool:
    """Validate that user owns the message's conversation"""
    message = session.exec(
        select(Message)
        .join(Conversation)
        .where(Message.id == message_id)
        .where(Conversation.user_id == user_id)
    ).first()
    return message is not None
```

**Enforcement Points**:
1. Before reading any conversation or message
2. Before updating any conversation
3. Before deleting any conversation
4. Before creating messages in a conversation

---

## Performance Contracts

### Query Performance Targets

**Contract**: All queries must meet these performance targets

| Operation | Target | Constraint |
|-----------|--------|------------|
| List conversations | <100ms | With user_id index |
| Get conversation messages | <200ms | With conversation_id index |
| Create message | <50ms | Single insert |
| Update conversation | <50ms | Single update |

**Optimization Requirements**:
- Use indexes on `user_id`, `conversation_id`, `created_at`, `updated_at`
- Lazy load messages (don't fetch with conversation list)
- Support pagination for large result sets
- Use connection pooling for concurrent requests

---

## Data Integrity Contracts

### Foreign Key Constraints

**Contract**: Database enforces referential integrity

1. **Conversation → User**:
   - `conversation.user_id` MUST reference existing `user.id`
   - Constraint: RESTRICT on delete (preserve conversations if user deleted)

2. **Message → Conversation**:
   - `message.conversation_id` MUST reference existing `conversation.id`
   - Constraint: CASCADE on delete (delete messages when conversation deleted)

### Immutability Contracts

**Contract**: Certain data is immutable after creation

1. **Messages are immutable**:
   - No UPDATE operations allowed on messages
   - Only INSERT and DELETE (via conversation cascade)

2. **Conversation ownership is immutable**:
   - `user_id` cannot be changed after creation
   - Conversations cannot be transferred between users

---

## Error Handling Contracts

### Expected Errors

**Contract**: Application code must handle these error cases

1. **Conversation Not Found**:
   - Return: `None` or 404 Not Found
   - Do NOT raise exception

2. **Permission Denied**:
   - Return: 403 Forbidden
   - When user tries to access conversation they don't own

3. **Foreign Key Violation**:
   - Return: 400 Bad Request
   - When trying to create message for non-existent conversation

4. **Validation Error**:
   - Return: 422 Unprocessable Entity
   - When message content exceeds 10,000 characters
   - When role is invalid

---

## Usage Examples

### Complete Conversation Flow

```python
from database.session import get_session
from models.conversation import Conversation
from models.message import Message, MessageRole
from datetime import datetime

def create_conversation_with_messages(user_id: str, title: str, messages_data: list):
    """Complete flow: create conversation and add messages"""
    with next(get_session()) as session:
        # 1. Create conversation
        conversation = Conversation(
            user_id=user_id,
            title=title
        )
        session.add(conversation)
        session.commit()
        session.refresh(conversation)

        # 2. Add messages
        for msg_data in messages_data:
            message = Message(
                conversation_id=conversation.id,
                role=msg_data["role"],
                content=msg_data["content"]
            )
            session.add(message)

        # 3. Update conversation timestamp
        conversation.updated_at = datetime.utcnow()
        session.add(conversation)

        session.commit()
        return conversation.id

# Usage
conv_id = create_conversation_with_messages(
    user_id="user_123",
    title="Python Discussion",
    messages_data=[
        {"role": MessageRole.USER, "content": "What are Python best practices?"},
        {"role": MessageRole.ASSISTANT, "content": "Here are some key practices..."}
    ]
)
```

---

## Contract Validation

Before deploying, verify:
- [ ] All queries filter by user_id for user isolation
- [ ] Messages are ordered chronologically
- [ ] Conversation timestamps update when messages added
- [ ] Foreign key constraints are enforced
- [ ] Performance targets are met
- [ ] Error cases are handled gracefully
- [ ] No SQL injection vulnerabilities (use parameterized queries)
