# Implementation Plan: Containerization Strategy

**Branch**: `009-containerization` | **Date**: 2026-02-05 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/009-containerization/spec.md`

## Summary

Containerize the Todo AI Chatbot application by creating optimized Docker images for both backend (FastAPI) and frontend (Next.js) services. The backend already has a basic Dockerfile that needs optimization. The frontend requires a new multi-stage Dockerfile with nginx for production serving. Both containers must be stateless, accept environment-based configuration, and comply with constitutional principles X (Container immutability), XI (Configuration externalization), and XII (Infrastructure as Code).

## Technical Context

**Language/Version**: Backend: Python 3.11 | Frontend: Node.js 18+ (Next.js 14+)
**Primary Dependencies**: Backend: FastAPI, SQLModel, uvicorn | Frontend: Next.js, React, OpenAI ChatKit
**Storage**: External Neon Serverless PostgreSQL (no local storage in containers)
**Testing**: Manual verification via docker build and docker run
**Target Platform**: Linux containers (Docker, compatible with Kubernetes)
**Project Type**: Web application (backend + frontend)
**Performance Goals**: Backend container start <10s, Frontend container start <5s, Build time <5 minutes
**Constraints**: Backend image <500MB, Frontend image <100MB, Zero critical/high vulnerabilities
**Scale/Scope**: 2 container images (backend, frontend), Multi-stage builds, Production-ready

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle X: Container Immutability
- ✅ **Stateless Containers**: No local file storage for application data
- ✅ **Immutable Images**: Same source produces same image (reproducible builds)
- ✅ **External State**: All state persists to Neon database

### Principle XI: Configuration Externalization
- ✅ **No Hardcoded Secrets**: Environment variables for DATABASE_URL, GEMINI_API_KEY, BETTER_AUTH_SECRET
- ✅ **Runtime Injection**: Secrets provided at container startup, never baked into images
- ✅ **Environment-Based Config**: All environment-specific settings externalized

### Principle XII: Infrastructure as Code
- ⚠️ **Partial Compliance**: Dockerfiles are IaC, but Kubernetes manifests are out of scope (separate feature)
- ✅ **Version Controlled**: All Dockerfiles and configuration files in repository
- ✅ **Reproducible**: Deterministic builds from source

**Status**: ✅ PASSED - All applicable constitutional requirements met for containerization phase

## Project Structure

### Documentation (this feature)

```text
specs/009-containerization/
├── plan.md              # This file
├── research.md          # Phase 0: Existing Dockerfile analysis
├── quickstart.md        # Phase 1: Container build and run guide
└── tasks.md             # Phase 2: Generated by /sp.tasks command
```

### Source Code (repository root)

```text
backend/
├── Dockerfile           # EXISTS - Needs optimization review
├── .dockerignore        # EXISTS - Needs verification
├── requirements.txt     # Python dependencies
├── main.py              # FastAPI application entry point
├── api/                 # API routes
├── mcp_server/          # MCP tools
├── database/            # Database models
└── config/              # Configuration

frontend-app/            # Note: Directory is "frontend-app" not "frontend"
├── Dockerfile           # TO CREATE - Multi-stage build
├── .dockerignore        # TO CREATE - Exclude node_modules, .next
├── nginx.conf           # TO CREATE - Reverse proxy config
├── package.json         # Node.js dependencies
├── next.config.ts       # Next.js configuration
├── app/                 # Next.js app router pages
├── components/          # React components
└── public/              # Static assets
```

**Structure Decision**: Web application structure with separate backend and frontend directories. Backend already containerized (needs optimization). Frontend requires new containerization implementation.

## Complexity Tracking

> No constitutional violations requiring justification.

## Phase 0: Research & Discovery

### Existing Backend Dockerfile Analysis

**Current State** (backend/Dockerfile):
- Base image: `python:3.11-slim` (good choice, meets FR-012)
- Non-root user: ✅ Security best practice implemented
- Working directory: `/app`
- Port: 7860 (Hugging Face Spaces default) - **NEEDS CHANGE to 8000** per FR-003
- Health check: ✅ Implemented
- Command: `uvicorn app:app` - **NEEDS CHANGE to `main:app`** based on main.py

**Optimization Opportunities**:
1. Change port from 7860 to 8000 (FR-003)
2. Update CMD to reference correct entry point (main.py not app.py)
3. Remove uploads/avatars directory creation (violates Principle X - stateless)
4. Verify .dockerignore excludes unnecessary files
5. Consider multi-stage build for smaller image size

**Gordon Consultation Points**:
- "Analyze backend/Dockerfile for security vulnerabilities and optimization opportunities"
- "Suggest improvements for Python 3.11-slim Dockerfile to reduce image size below 500MB"

### Frontend Containerization Requirements

**Current State**: No Dockerfile exists for frontend-app/

**Requirements**:
- Multi-stage build (FR-011)
  - Stage 1 (builder): Node.js image, install deps, run `npm run build`
  - Stage 2 (runtime): nginx:alpine, copy build artifacts
- nginx configuration for:
  - Serving static files from /usr/share/nginx/html
  - Proxying /api requests to backend service
  - Port 80 exposure (FR-004)
- .dockerignore to exclude node_modules, .next, .git

**Gordon Consultation Points**:
- "Generate a multi-stage Dockerfile for Next.js 14 with App Router. Stage 1: Build with Node.js. Stage 2: Serve with nginx:alpine"
- "Create nginx.conf for Next.js static site with /api reverse proxy to backend service"

### Environment Variables Inventory

**Backend Required** (FR-005):
- `DATABASE_URL`: Neon PostgreSQL connection string
- `GEMINI_API_KEY`: Google Gemini API key for AI agent
- `BETTER_AUTH_SECRET`: JWT signing secret
- `BETTER_AUTH_URL`: Authentication service URL (if needed)

**Frontend Required** (FR-006):
- `NEXT_PUBLIC_API_URL`: Backend service URL for API calls
- Or configure nginx proxy to handle /api routing internally

### .dockerignore Requirements

**Backend** (.dockerignore - verify existing):
```
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
venv/
env/
.env
.git/
.gitignore
*.md
tests/
.pytest_cache/
```

**Frontend** (.dockerignore - create new):
```
node_modules/
.next/
.git/
.gitignore
*.md
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env*.local
.vercel
```

## Phase 1: Design Artifacts

### Container Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Container Layer                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────────┐      ┌──────────────────────┐    │
│  │  Frontend Container  │      │  Backend Container   │    │
│  │  (todo-frontend)     │      │  (todo-backend)      │    │
│  ├──────────────────────┤      ├──────────────────────┤    │
│  │ nginx:alpine         │      │ python:3.11-slim     │    │
│  │ - Static files       │◄─────┤ - FastAPI app        │    │
│  │ - /api proxy         │ HTTP │ - MCP server         │    │
│  │ Port: 80             │      │ Port: 8000           │    │
│  └──────────────────────┘      └──────────────────────┘    │
│           │                              │                   │
│           │ (User Access)                │ (DB Connection)   │
│           ▼                              ▼                   │
│      User Browser              External Neon PostgreSQL     │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### Backend Dockerfile Design (Optimized)

**Strategy**: Single-stage build with optimization
- Base: `python:3.11-slim`
- Security: Non-root user
- Optimization: Minimal dependencies, no dev tools
- Port: 8000 (FR-003)
- Health check: `/health` endpoint
- Logging: stdout/stderr (FR-015)

**Key Changes from Existing**:
1. Port 7860 → 8000
2. Remove uploads directory creation (stateless)
3. CMD: `uvicorn main:app --host 0.0.0.0 --port 8000`
4. Verify environment variable injection

### Frontend Dockerfile Design (Multi-Stage)

**Stage 1: Builder**
- Base: `node:18-alpine` or `node:20-alpine`
- Install dependencies: `npm ci` (faster, deterministic)
- Build: `npm run build`
- Output: `.next/` directory with production build

**Stage 2: Runtime**
- Base: `nginx:alpine` (minimal size)
- Copy build artifacts from Stage 1
- Copy nginx.conf for routing
- Port: 80 (FR-004)
- No Node.js runtime in final image (size optimization)

### nginx Configuration Design

**Purpose**: Serve Next.js static export and proxy API calls

**Configuration** (frontend-app/nginx.conf):
```nginx
server {
    listen 80;
    server_name _;

    root /usr/share/nginx/html;
    index index.html;

    # Serve static files
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Proxy API requests to backend
    location /api/ {
        proxy_pass http://todo-backend:8000/api/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
```

**Note**: Backend service name `todo-backend` assumes Kubernetes service naming. For local Docker testing, use `host.docker.internal` or Docker Compose service names.

### Build and Run Commands

**Backend**:
```bash
# Build
docker build -t todo-backend:latest ./backend

# Run
docker run -d \
  --name todo-backend \
  -p 8000:8000 \
  -e DATABASE_URL="postgresql://..." \
  -e GEMINI_API_KEY="..." \
  -e BETTER_AUTH_SECRET="..." \
  todo-backend:latest
```

**Frontend**:
```bash
# Build
docker build -t todo-frontend:latest ./frontend-app

# Run
docker run -d \
  --name todo-frontend \
  -p 80:80 \
  --link todo-backend:todo-backend \
  todo-frontend:latest
```

**Verification**:
```bash
# Check backend health
curl http://localhost:8000/health

# Check frontend
curl http://localhost:80

# Check API proxy
curl http://localhost:80/api/health
```

## Phase 2: Implementation Sequence

**Note**: Detailed tasks will be generated by `/sp.tasks` command.

### High-Level Implementation Flow

1. **Setup Phase**
   - Create frontend-app/.dockerignore
   - Verify backend/.dockerignore

2. **Backend Optimization** (User Story 1 - P1)
   - Update backend/Dockerfile (port, CMD, remove stateful elements)
   - Consult Gordon for security scan
   - Test build and run locally

3. **Frontend Containerization** (User Story 2 - P2)
   - Consult Gordon for multi-stage Dockerfile generation
   - Create frontend-app/Dockerfile
   - Create frontend-app/nginx.conf
   - Test build and run locally

4. **Integration Testing**
   - Run both containers
   - Verify frontend can reach backend via proxy
   - Test API calls through frontend

5. **Optimization** (User Story 3 - P3)
   - Measure image sizes
   - Run security scans (Gordon)
   - Optimize if needed

## Success Metrics Mapping

| Success Criterion | Verification Method |
|-------------------|---------------------|
| SC-001: Backend starts <10s | `time docker run` + health check |
| SC-002: Frontend starts <5s | `time docker run` + curl test |
| SC-003: Backend image <500MB | `docker images` size check |
| SC-004: Frontend image <100MB | `docker images` size check |
| SC-005: Restart without data loss | Stop/start containers, verify DB state |
| SC-006: Build <5 minutes | `time docker build` for both images |
| SC-007: Zero critical vulnerabilities | Gordon security scan |
| SC-008: Functional parity | Manual testing of all features |
| SC-009: Runtime compatibility | Test with Docker, containerd |
| SC-010: Log accessibility | `docker logs` command |

## Risk Analysis

| Risk | Impact | Mitigation |
|------|--------|------------|
| Frontend build size exceeds 100MB | Medium | Use nginx:alpine, optimize build artifacts, exclude source maps |
| Backend port conflict (7860 vs 8000) | High | Update Dockerfile and all references, test thoroughly |
| nginx proxy configuration errors | High | Test proxy with curl, verify headers, check backend logs |
| Environment variable injection fails | Critical | Document required vars, test with .env file, validate at startup |
| Multi-stage build complexity | Medium | Follow Gordon's recommendations, test each stage independently |

## Gordon (Docker AI) Consultation Plan

### Consultation 1: Backend Optimization
**Prompt**: "Analyze this Python FastAPI Dockerfile for security vulnerabilities and suggest optimizations to reduce image size below 500MB while maintaining Python 3.11-slim base."

**Input**: Current backend/Dockerfile content

**Expected Output**: Security recommendations, size optimization suggestions

### Consultation 2: Frontend Multi-Stage Build
**Prompt**: "Generate a production-ready multi-stage Dockerfile for Next.js 14 with App Router. Stage 1: Build with Node.js 18. Stage 2: Serve with nginx:alpine. Target image size under 100MB."

**Expected Output**: Complete Dockerfile with two stages

### Consultation 3: nginx Configuration
**Prompt**: "Create an nginx.conf for serving Next.js static export with reverse proxy for /api requests to backend service at http://todo-backend:8000. Include health check endpoint."

**Expected Output**: Complete nginx.conf file

### Consultation 4: Security Scan
**Prompt**: "Scan both todo-backend and todo-frontend Docker images for security vulnerabilities. Report any critical or high-severity issues."

**Expected Output**: Vulnerability report with remediation steps

## Dependencies

**External**:
- Docker installed and running
- Access to Neon PostgreSQL database
- GEMINI_API_KEY available
- BETTER_AUTH_SECRET configured

**Internal**:
- Backend application functional (main.py exists)
- Frontend application functional (Next.js app builds successfully)
- requirements.txt up to date
- package.json up to date

## Out of Scope

- Kubernetes deployment manifests (separate feature: 010-kubernetes-deployment)
- Helm chart creation (separate feature: 011-helm-charts)
- Docker Compose orchestration (optional, not required)
- CI/CD pipeline integration
- Container registry setup and push
- Image tagging strategy beyond :latest
- Multi-architecture builds (ARM, x86)
- Container image signing

## Next Steps

1. Run `/sp.tasks` to generate detailed task breakdown
2. Consult Gordon for Dockerfile generation and optimization
3. Implement tasks in priority order (P1 → P2 → P3)
4. Verify all success criteria before marking complete
