# Data Model: Chat Conversation Persistence

**Feature**: 003-chat-database-schema
**Date**: 2026-01-29
**Based on**: Existing backend structure at `backend/models/task_models.py`

## Overview

This data model extends the existing Phase 2 schema (User and Task models from `backend/models/task_models.py`) to support persistent chat conversations. It introduces two new entities: **Conversation** and **Message**, which work together to store all user interactions with the AI chatbot.

**Key Pattern Alignment**: Follows existing patterns from `task_models.py` including table naming (lowercase singular), timestamp handling (`datetime.utcnow`), and relationship definitions.

## Entity Definitions

### Conversation Entity

**Conversation**: Represents a chat session between a user and the AI assistant. Contains metadata about the conversation including when it was created, last updated, and an optional title.

**Fields**:
- **id**: Unique identifier (integer, auto-increment, primary key)
- **user_id**: Foreign key linking to the owning user (string, required, indexed)
- **title**: Conversation title for organization (string, optional, max length 255)
- **created_at**: Creation timestamp (datetime with timezone, auto-generated, UTC)
- **updated_at**: Last update timestamp (datetime with timezone, auto-updated, UTC)

**Constraints**:
- `id` is PRIMARY KEY with auto-increment
- `user_id` is NOT NULL and FOREIGN KEY to `users.id`
- `title` is nullable (VARCHAR 255)
- `created_at` is NOT NULL with default `datetime.utcnow`
- `updated_at` is NOT NULL with default `datetime.utcnow`, auto-updated on modification

**Indexes**:
- Primary index on `id` (automatic)
- Index on `user_id` for efficient user-scoped queries (FR-003)
- Index on `updated_at` for sorting by recency (FR-008)

**Relationships**:
- One-to-many with Message: `messages: List["Message"]` (back_populates="conversation")
- Many-to-one with User: `user_id` references `users.id`

---

### Message Entity

**Message**: Represents a single message within a conversation. Contains the message content, the role of the sender (user, assistant, or system), and when it was created.

**Fields**:
- **id**: Unique identifier (integer, auto-increment, primary key)
- **conversation_id**: Foreign key linking to parent conversation (integer, required, indexed)
- **role**: Message sender role (enum: "user", "assistant", "system", required)
- **content**: Message text content (TEXT, required, max 10,000 characters)
- **created_at**: Creation timestamp (datetime with timezone, auto-generated, UTC)

**Constraints**:
- `id` is PRIMARY KEY with auto-increment
- `conversation_id` is NOT NULL and FOREIGN KEY to `conversations.id` with CASCADE on delete
- `role` is NOT NULL and CHECK constraint IN ('user', 'assistant', 'system')
- `content` is NOT NULL (TEXT type supports up to 10,000+ characters per SC-004)
- `created_at` is NOT NULL with default `datetime.utcnow`

**Indexes**:
- Primary index on `id` (automatic)
- Index on `conversation_id` for efficient message retrieval (FR-010)
- Index on `created_at` for chronological ordering (FR-006)

**Relationships**:
- Many-to-one with Conversation: `conversation: "Conversation"` (back_populates="messages")

---

## Message Role Enumeration

**MessageRole**: Python Enum defining valid message sender roles

```python
class MessageRole(str, Enum):
    USER = "user"          # Message from the human user
    ASSISTANT = "assistant"  # Message from the AI assistant
    SYSTEM = "system"       # System-generated message (e.g., notifications)
```

**Storage**: Stored as VARCHAR(20) in database
**Validation**: Type-safe at application level, prevents invalid role values
**Compatibility**: Follows OpenAI/LLM conversation format standards

---

## Relationship Patterns

### User-Conversation Association
- **Cardinality**: One user can own many conversations (1:N relationship)
- **Foreign Key**: `Conversation.user_id` → `User.id`
- **Cascade Behavior**: No cascade delete (preserve data integrity)
- **Index**: Required on `user_id` for efficient querying
- **Isolation**: All conversation queries MUST filter by authenticated user_id (FR-003)

### Conversation-Message Association
- **Cardinality**: One conversation contains many messages (1:N relationship)
- **Foreign Key**: `Message.conversation_id` → `Conversation.id`
- **Cascade Behavior**: CASCADE on delete (when conversation is deleted, all messages are deleted)
- **Index**: Required on `conversation_id` for efficient message retrieval
- **Ordering**: Messages ordered by `created_at` ASC within each conversation (FR-006)

---

## Validation Rules

### Conversation Creation
- `user_id` is required and must correspond to an existing authenticated user
- `title` is optional; if not provided, can be auto-generated from first message
- `created_at` and `updated_at` are auto-generated by the system
- User can only create conversations for themselves (validated against JWT claims)

### Conversation Updates
- User can only update conversations they own (validated against JWT claims)
- `title` can be modified (max 255 characters)
- `updated_at` is automatically updated by the system on any modification
- Cannot change `user_id` after creation (immutable)

### Message Creation
- `conversation_id` is required and must reference an existing conversation
- User can only add messages to conversations they own (validated via conversation ownership)
- `role` must be one of: "user", "assistant", "system"
- `content` is required and must be between 1-10,000 characters
- `created_at` is auto-generated by the system
- Messages are immutable after creation (no updates allowed)

### Message Retrieval
- Messages are always retrieved in chronological order (`created_at` ASC)
- User can only retrieve messages from conversations they own
- System must support efficient retrieval of 1000+ messages per conversation (SC-004)

---

## State Transitions

### Conversation Lifecycle
1. **Created**: New conversation with optional title, empty message list
2. **Active**: Conversation with one or more messages
3. **Updated**: Conversation title modified or new message added (updates `updated_at`)
4. **Archived**: (Future enhancement - not in current scope)
5. **Deleted**: Conversation and all associated messages permanently removed

### Message Lifecycle
1. **Created**: New message added to conversation
2. **Persisted**: Message durably stored and retrievable (immutable)
3. **Deleted**: Message removed when parent conversation is deleted (CASCADE)

---

## Query Patterns

### Efficient Access Patterns

**List User's Conversations** (Primary use case):
```sql
SELECT * FROM conversations
WHERE user_id = ?
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
```
- Uses index on `user_id` and `updated_at`
- Supports pagination for users with 100+ conversations (SC-005)

**Get Conversation Messages** (Primary use case):
```sql
SELECT * FROM messages
WHERE conversation_id = ?
ORDER BY created_at ASC
```
- Uses index on `conversation_id` and `created_at`
- Supports 1000+ messages per conversation (SC-004)

**Get Single Conversation with Ownership Validation**:
```sql
SELECT * FROM conversations
WHERE id = ? AND user_id = ?
```
- Uses primary key and user_id index
- Enforces user isolation (SC-007)

**Insert Message**:
```sql
INSERT INTO messages (conversation_id, role, content, created_at)
VALUES (?, ?, ?, ?)
```
- Updates parent conversation's `updated_at` timestamp (via application logic or trigger)

**Count User's Conversations**:
```sql
SELECT COUNT(*) FROM conversations
WHERE user_id = ?
```
- Uses index on `user_id`

---

## Performance Considerations

### Indexing Strategy
- **conversations.user_id**: Critical for user-scoped queries (all conversation operations)
- **conversations.updated_at**: Required for sorting by recency (conversation list)
- **messages.conversation_id**: Critical for message retrieval (primary access pattern)
- **messages.created_at**: Required for chronological ordering (message display)

### Optimization Techniques
- **Lazy Loading**: Don't load all messages when fetching conversation list
- **Pagination**: Use LIMIT/OFFSET for large conversation lists
- **Batch Inserts**: Support efficient insertion of multiple messages
- **Connection Pooling**: Reuse database connections for better performance

### Scalability Targets
- Support 1000+ messages per conversation without degradation (SC-004)
- Support 100+ concurrent conversations per user (SC-005)
- Conversation retrieval in <2 seconds (SC-002)
- Zero data loss during normal operation (SC-006)

---

## Data Isolation & Security

### User Isolation Enforcement (FR-003)
- Every conversation MUST have a `user_id` foreign key
- All conversation queries MUST filter by authenticated user's ID from JWT
- All message queries MUST validate conversation ownership before access
- Cross-user access attempts MUST return 403 Forbidden

### Security Principles
- User ID derived exclusively from verified JWT claims (never from URL parameters alone)
- Foreign key constraints prevent orphaned messages
- Indexes on `user_id` ensure efficient isolation checks
- No shared conversations between users (single-owner model)

---

## Database Schema SQL

### Conversations Table
```sql
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    title VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (NOW() AT TIME ZONE 'utc'),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (NOW() AT TIME ZONE 'utc'),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at);
```

### Messages Table
```sql
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (NOW() AT TIME ZONE 'utc'),
    FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
);

CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

---

## SQLModel Implementation Pattern

### Conversation Model
```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from typing import Optional, List

class Conversation(SQLModel, table=True):
    """
    Represents a chat session between a user and the AI assistant.

    Relationships:
    - Belongs to one User (via user_id)
    - Has many Messages (via messages relationship)
    """
    __table_args__ = {'extend_existing': True}
    __tablename__ = "conversation"  # Singular, matching existing pattern

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="user.id", index=True)  # Matches existing "user" table
    title: Optional[str] = Field(default=None, max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow, sa_column_kwargs={"index": True})

    # Relationships
    messages: List["Message"] = Relationship(back_populates="conversation")
```

### Message Model
```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from typing import Optional
from enum import Enum

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"

class Message(SQLModel, table=True):
    """
    Represents a single message within a conversation.

    Relationships:
    - Belongs to one Conversation (via conversation_id)
    """
    __table_args__ = {'extend_existing': True}
    __tablename__ = "message"  # Singular, matching existing pattern

    id: Optional[int] = Field(default=None, primary_key=True)
    conversation_id: int = Field(foreign_key="conversation.id", index=True)
    role: MessageRole = Field(...)
    content: str = Field(..., max_length=10000)
    created_at: datetime = Field(default_factory=datetime.utcnow, sa_column_kwargs={"index": True})

    # Relationships
    conversation: "Conversation" = Relationship(back_populates="messages")
```

**Note**: Follows existing backend patterns:
- `__table_args__ = {'extend_existing': True}` for development flexibility
- `datetime.utcnow` (not timezone-aware) matching existing Task model
- Table names are lowercase singular ("conversation", "message")
- Foreign keys reference lowercase singular table names ("user.id", "conversation.id")

---

## Schema Creation Strategy

### SQLModel Metadata Approach (No Alembic)
- **Method**: Uses `SQLModel.metadata.create_all(engine)` from `backend/database/migrations.py`
- **Automatic**: Tables created on application startup
- **Models**: Add to `backend/models/conversation.py` and `backend/models/message.py`
- **Import**: Update `backend/models/__init__.py` to import new models
- **Execution**: Run `python backend/database/migrations.py` or start application

### Schema Creation Steps
1. Create model files: `backend/models/conversation.py` and `backend/models/message.py`
2. Import models in `backend/models/__init__.py`
3. Run migrations: `python backend/database/migrations.py`
4. Verify tables created: Check database for "conversation" and "message" tables

### Dependencies
- Requires existing `user` table (from Phase 2)
- No changes to existing Task or User models
- Maintains backward compatibility

---

## Assumptions & Constraints

### Assumptions
- Conversations are never automatically deleted (persist indefinitely)
- Message content is plain text (no rich formatting or attachments)
- Conversation titles are optional and can be auto-generated
- All timestamps use UTC timezone
- User isolation is enforced at data layer
- Messages are immutable after creation

### Constraints
- Must maintain backward compatibility with existing Task and User models
- All database I/O must be async-compatible
- Must support 1000+ messages per conversation
- Must support 100+ conversations per user
- Message content limited to 10,000 characters
- No cascade delete from User to Conversation (preserve data integrity)

---

## Verification Checklist

Before considering this data model complete, verify:
- [ ] All fields have proper type hints and constraints
- [ ] Foreign keys are defined with correct `ondelete` behavior
- [ ] Indexes exist on frequently queried columns
- [ ] Nullable vs. non-nullable fields match business requirements
- [ ] Timestamps use UTC timezone
- [ ] Model docstrings explain purpose and relationships
- [ ] Data isolation by user_id is enforced
- [ ] Async compatibility is maintained
- [ ] No hardcoded values or secrets in models
- [ ] Follows existing patterns from Task model
